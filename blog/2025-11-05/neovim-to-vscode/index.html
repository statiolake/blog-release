<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="statiolake の雑記帳、またはログ。"><title>/var/log - 6500 行以上設定を書いた Neovimmer が VS Code に軸足を移す理由。</title><meta property="og:url" content="https://blog.statiolake.net/blog/2025-11-05/neovim-to-vscode/"><meta property="og:site_name" content="/var/log"><meta property="og:title" content="6500 行以上設定を書いた Neovimmer が VS Code に軸足を移す理由。"><meta property="og:description" content="私は Neovimmer であり、かなりの時間を Neovim とともに過ごしてきた。dotfiles の Neovim の設定は 6500 行にものぼるらしい。 これでも使っていない built-in LSP 関連の設定をまるっと削除したり、ユーティリティを自作のプラグインとして切り出したりした後なので、昔より若干行数が減っているはずである。"><meta property="og:locale" content="ja_JP"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-11-05T07:27:30+00:00"><meta property="article:modified_time" content="2025-11-05T07:27:30+00:00"><meta property="article:tag" content="Neovim"><meta property="article:tag" content="Vscode"><meta property="article:tag" content="Poem"><meta property="og:image" content="https://blog.statiolake.net/icon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.statiolake.net/icon.png"><meta name=twitter:title content="6500 行以上設定を書いた Neovimmer が VS Code に軸足を移す理由。"><meta name=twitter:description content="私は Neovimmer であり、かなりの時間を Neovim とともに過ごしてきた。dotfiles の Neovim の設定は 6500 行にものぼるらしい。 これでも使っていない built-in LSP 関連の設定をまるっと削除したり、ユーティリティを自作のプラグインとして切り出したりした後なので、昔より若干行数が減っているはずである。"><meta name=twitter:site content="@https://x.com/statiolake"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel=stylesheet crossorigin=anonymous><link rel=stylesheet href=/iosevka/IosevkaFixed.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/style.min.css></head><body><header class=site-header><nav class=site-nav><div class=site-branding><a href=https://blog.statiolake.net/ class=logo>/var/log</a><p class=site-description>statiolake の雑記帳、またはログ。</p></div><div class=nav-links></div></nav></header><main><article class=post><header><h1>6500 行以上設定を書いた Neovimmer が VS Code に軸足を移す理由。</h1><div class=post-meta><time datetime=2025-11-05T07:27:30Z class=post-date>2025-11-05</time><div class=post-tags><a href=/tags/neovim class=tag>#neovim</a>
<a href=/tags/vscode class=tag>#vscode</a>
<a href=/tags/poem class=tag>#poem</a></div></div></header><div class=content><p>私は Neovimmer であり、かなりの時間を Neovim とともに過ごしてきた。dotfiles の Neovim の設定は 6500 行にものぼるらしい。
これでも使っていない built-in LSP 関連の設定をまるっと削除したり、ユーティリティを自作のプラグインとして切り出したりした後なので、昔より若干行数が減っているはずである。</p><pre tabindex=0><code>$ tokei
===============================================================================
 Language            Files        Lines         Code     Comments       Blanks
===============================================================================
 JavaScript              2           55           50            2            3
 JSON                   12         2221         2221            0            0
 Lua                    53         6526         4975          963          588
 Markdown                1            3            0            2            1
 TOML                    2          676           66          478          132
 TypeScript              1            3            2            0            1
 Vim script              3          446          430            4           12
===============================================================================
 Total                  74         9930         7744         1449          737
===============================================================================
</code></pre><p>Neovim を使う熱意に関しては、自分でいうのもなんだが、人並みよりだいぶ強かったと思う。</p><p>VS Code + Dev Container が一世を風靡したときは、私は <a href=https://github.com/statiolake/dockim>dockim</a> というツールを作って Neovim を使い続けた。
このツールは Dev Container CLI のラッパーである。Neovim のセットアップを <code>dockim build</code> だけで終わらせるほか、Dev Container CLI に欠けているポート転送などの機能を補った。
dotfiles のセットアップスクリプトと連携して zsh のセットアップなども一括で終わらせるので、何なら本家 VS Code の Dev Container よりも便利まであった。</p><p>GitHub Copilot Chat が巷を席巻したときは、VS Code LM API それ自体を Neovim に持ち込んでやろうと思った。簡単なチャットが coc.nvim 上で行えるくらいまでにはなった。その後 Claude Code だったり Copilot CLI が出てきたので、結局は中途半端なところで放り出してしまったが。</p><p>しかし、そこには結局、ずっと目を背けてきた現実があった。
すなわち、私が私の理想とする開発環境に最も近いのは、今のところ Neovim ではなく VS Code なのではないか、ということだ。</p><h2 id=理想の開発環境とは>理想の開発環境とは？</h2><p>私にとっての理想の開発環境とは、それ一つですべてのニーズをかなえられる環境である。
本来エンジニアであれば、必要なところに適切なツールを投入して解決するほうが適切なのかもしれない。それでも私にとっての開発環境は道具というよりは家であったので、この家ですべてのことができるのかどうか、それが重要だった。
そして叶うなら、これからの自分に発生するニーズに対して、それを実装できるだけの柔軟な基盤があること。それらの拡張がプラガブルで直交していること。</p><p>今の世界でその環境に最も簡単に近づけるのは VS Code であるというのが最近の結論だ。</p><h2 id=vs-code-の何がそんなにすごいのか>VS Code の何がそんなにすごいのか</h2><p>自分が Neovim と大きく違いを感じているのは、主に以下の点である。</p><ol><li>GUI のクライアント + サーバーという理想的な分業</li><li>JSON による宣言的で「動かない」設定と、API を通じた疎結合な拡張機能</li><li>圧倒的シェアのもとのエコシステム</li><li>大規模ファイルの取り扱いとパフォーマンス</li></ol><h2 id=1-gui-クライアント--サーバーの理想的な分業>1. GUI クライアント + サーバーの理想的な分業</h2><p>いきなりターミナルエディタ愛好家からブーイングを受けそうなポイントだが、私個人としては、これだ。最も大きいのは。</p><p>Neovimmer でありながら、実は私はあまり TUI が好みではない。というよりも、GUI の方が必ず TUI よりもよい UI を達成可能だと考えている。
もちろん、特定の GUI がごちゃついていて、別の TUI の方がシンプルで使いやすい、ということは常に起こりうる。だが、それはあくまでも個別の UI デザインの問題である。tmux で切り替えが容易という意見もあるかもしれないが、それもウィンドウマネージャの問題である。
技術要素として見たとき、あなたが X11 も Wayland も入れていない Linux をデスクトップ利用しているのでなければ、UI を構築する点において GUI の方が優れているという点には同意してもらえると思う。極端な話、本当に TUI が理想なのであれば GUI で TUI を完全再現すれば少なくとも劣ることはない。</p><p>ただし、GUI が明確に弱い場面が存在する ‐ それがリモート接続である。この点においては、SSH するだけで利用可能になる TUI に軍配が上がる。</p><p>その当たり前の壁を貫通してきたのは VS Code (Remote Development) であった。</p><p>接続先がコンテナであろうと SSH であろうと、VS Code のクライアントは手元の GUI で動いている。一方、VS Code の拡張機能ホストを始めとしたコアはリモートサーバーで動いている。このため「リモートサーバー上で稼働する GUI を手元に持ってくる」ということが何も考えなくてもできてしまうのである。わかりやすい話が Markdown のプレビューアで、リモートサーバー上の Markdown ファイルのプレビューをローカルの VS Code から普通に見ることができる。私が TeX をコンテナ環境に作ったときは SyncTeX できるプレビューアのために何かを諦めるしかなかったというのに。</p><p>そうだ。もう一つ、細かいけれども強力な点の話をしておきたい。
GUI が手前で動いているため、コピー & ペーストについて何も考えなくて良いというのがある。Neovim では、手前で動いているのがターミナルエミュレータしかないため、コンテナで動いている Neovim で <code>"+y</code> するのは非常に困難だった。
tmux と OSC で頑張るというのも一つではあるが、結局エスケープシーケンスというやつはアプリケーションとターミナルマルチプレクサとターミナルとがすべていい感じにセットアップされていないと動かない。私は 24-bit color すら OS をまたぐとうまく動かないことがあり、到底安定した代物ではなかった。
前述の dockim では、クリップボードの中身を参照更新できる TCP サーバーをローカルに立て、コンテナ内の Neovim の <code>g:clipboard</code> にそのクライアントを設定することで対応していた。しかし、これはコピペの度に TCP 通信を行う必要があって重かったし、そもそも socat を使ったポート転送の hack を実装していなければ実現すらできない。その上、クリップボード暴露サーバーが listen しているというのには、いくら localhost に制限するとは言ってもセキュリティリスクも存在する。</p><p>一方で VS Code の GUI はフル機能の VS Code 実装を持った GUI クライアントである (ローカルで使えるのだから当たり前なのだが) 。そのため、その気になればクリップボードはおろか、フル機能の拡張機能を UI 側で動かすことさえできる。実際、VSCodeVim なんかは UI 拡張として設定されているので、Remote SSH で遠いサーバーとつながっているときでもスムーズにカーソルを動かすことができる。</p><p>何はともあれ、GUI があるということは、それだけ拡張と改善の余地、ひいてはエディタの潜在能力が豊かにあるということに等しい。
実際に GUI をふんだんに生かした <a href="https://marketplace.visualstudio.com/items?itemName=statiolake.vscode-pahcer-ui">Pahcer UI</a> という拡張機能をつくっていたりもする。
この拡張機能についての詳細は Vim とは違う話なので割愛するが、とりあえず、グラフやホバー・リンクなど GUI の強みをふんだんに生かしたある種の可視化ツールである。いつか別記事で紹介しよう。</p><p>余談だが、単に GUI を持つだけであれば、Neovim GUI という類のソフトウェアが存在する。これを使うと上述のクリップボードの問題なんかは VS Code と同じように解決できたりする。
とはいっても、Neovim GUI は VS Code のそれに比べて遥かに薄く、せいぜいが Neovim 専用のターミナルエミュレータといったところだろう。
もちろん、Neovim 自体がサーバーとなり、それを可視化するフロントエンドを実装できるようなリッチな GUI を持つことが不可能なわけではない。個人的には OniVim などはかなり面白そうだった。OniVim 2 になって違う道に進んだまま Archive されてしまったけれど。
あるいは現代だと VSCode Neovim が一番その道に近いだろうか。</p><h2 id=2-json-による宣言的で動かない設定とapi-を通じた疎結合な拡張機能>2. JSON による宣言的で「動かない」設定と、API を通じた疎結合な拡張機能</h2><p>これは意見の分かれる話かもしれない。
実は、拡張機能を作り始めるだけであれば Neovim の方がよっぽど簡単だ。
プラグインマネージャでパスを通して init.lua から require すれば事足りる。
そもそも語弊を恐れずに言うと、Neovim においてはプラグインと設定に本質的な違いがない。
単に init.lua から外部ソースを source しているのと何ら変わりないので、プラグインでできることは init.lua に直書きしてもできる。
その自由度が Neovim であり、自分はその環境を長らく愛してきた (今も)。</p><p>一方で、それが悪く作用する部分もかなりある。
たとえばプラグインの設定をするというのは、Lua プラグインの世界では慣習的に <code>setup()</code> 関数を呼び出すことと同義である。しかし <code>setup()</code> 関数というのはただの関数なので、作者次第で様々な副作用を持つ。例えば二回呼び出したときの動作がどうなるかはプラグイン次第だし、特定のプラグインよりも前に <code>setup()</code> を呼んでいないとうまく動作しないこともある。</p><p>こうした状況が困るのは、例えばプロジェクト固有の設定をメンバー全員で共有したいケースである。</p><p>まずカレントディレクトリに <code>.nvim.lua</code> のようなファイルがあれば読む、ということはできる。
一応標準機能だけでもできたと思うが、私は <a href=https://github.com/klen/nvim-config-local>nvim-config-local</a> というプラグインを使っていた。
というのは <code>.nvim.lua</code> は Lua ファイルなので、ファイルの漏洩を含めて何でもできるスクリプトである。これを何の同意もなく勝手に実行されるのでは非常に危険だ。その点、前述のプラグインはファイルごとに信用するかどうか聞いてくれるようになっており、一度信頼してもハッシュ値が変わったら都度実行許可を求めるなど、最低限のガードレールが用意されていたためである。</p><p>ただ、仮にスクリプトを実行できたとしても、全員に効果のある <code>.nvim.lua</code> を書くことは正直不可能である。
例えばこのプロジェクトでは textwidth を 120 に設定したいと思ったとしよう。ここで <code>vim.opt.textwidth = 120</code> と <code>.nvim.lua</code> に書いたとする。これはしかし、少なくとも私の個人環境では動かない。なぜなら私はそもそも <code>init.lua</code> で、ファイルタイプごとに textwidth を自動設定する設定を入れているからだ。グローバルな初期値は何も意味を持たないまま上書きされてしまう。</p><p>LSP の設定などはもっと共通化の需要が大きいと思うが、もっとややこしい話をしなければならない。Rust の inlay hint に関する設定をしたくなっても、lspconfig を使っているのか、個別の <a href=https://github.com/mrcjkb/rustaceanvim>rustaceanvim</a> などのプラグインを使っているのかで話は変わる。プラグインマネージャで lazy load は設定していますか? 他のプラグインが LSP の hook やハンドラを上書きしていませんか?</p><p>結局、私は設定を JSON で管理できるという理由で、coc.nvim を好んで利用していた。coc.nvim は VS Code にインスパイアされた補完エンジン、というよりはもはや拡張機能ホストであり、設定は <code>.vim/coc-settings.json</code> に書く形になっていた。これはまさに VS Code と同じ形式である。私は設定をすべてここに統一する覚悟を決め、<code>coc-settings.json</code> で Neovim 本体の設定も変更できるようにする coc 拡張 <a href=https://github.com/statiolake/coc-vim-options>coc-vim-options</a> を書いた。つまり、coc.nvim を使っていて拙作の coc 拡張を入れてくれる人に限っては、<code>.vim/coc-settings.json</code> に <code>"vim-options.textwidth": 120</code> と設定すれば設定を共有できるようにはなったわけだ。めでたしめでたし。ではない。</p><p>もう気づいてしまった。coc.nvim を気に入るということは、要するに、VS Code の選定が私に一番合っていたということだ。</p><p>設定はあえて「動かせない」JSON とすること。実行順序関係がないただの宣言的なデータにすること。これによって複数の設定ファイルのマージが機械的に可能になるし、誰が書いても同じ設定を適用できる。</p><p>拡張機能はあえて厳密にコアと分離すること。Vim の場合はプラグインは設定でもあったので、区別なくすべての機能にアクセスできた。一方で VS Code では、拡張機能は API を通してしかエディタにアクセスできない。それはビルトインコマンドと同じ動作をユーザー側で再現できないという歯がゆさとして現れることもあるが、でも、プラグインごとの設定やインストール状態をきちんと分離してエディタ側で管理できるという確かなメリットを生んでいる。</p><h2 id=3-圧倒的シェアのもとのエコシステム>3. 圧倒的シェアのもとのエコシステム</h2><p>VS Code が大企業 Microsoft にバックアップされた圧倒的シェアを持つエディタであることは、どれだけ言葉を尽くしてもあらがうことのできない事実である。
何らかのツールがリリースされたとして、オフィシャルに何かエディタ統合を実装するとなれば、まず VS Code から始めない理由がない。基本的に GitHub 上でオープンソースとして提供されることが多い Neovim のプラグインと異なり、Marketplace という統一された配布サイトで <code>.vsix</code> という専用形式のファイルを配る方式なので、企業からすればプロプライエタリな拡張機能も提供しやすい面はあるだろう。実際 Copilot Chat は当初クローズドソースで配られていた。
Pylance がオープンソース化してくれたらうれしいのにと思わないわけではないが、私は自由ソフトウェア主義ではないので、提供されないよりは提供されていた方がありがたいと思っている。</p><h2 id=4-大規模ファイルの取り扱いとパフォーマンス>4. 大規模ファイルの取り扱いとパフォーマンス</h2><p>意外なことに、大規模ファイルの取り扱いは VS Code の方がうまい。そのため安心してファイルを開くことができる。</p><p>というと若干語弊があって、Neovim も素の状態ではかなり軽量だったような気もする。しかし Neovim を素の状態で使うことはない。特に何の注意も払っていなければ LSP や tree-sitter などのシンタックスハイライトを有効にしていることが多い。
このタイミングでとんでもなく大きいログや JSON を開くとどうなるか？ そう、固まるのである。こうなるともう Neovim を kill するしかない。さようなら、私の未保存の編集&mldr;。</p><p>VS Code の場合、まずは大規模ファイルは警告を表示してくれたり、長い行は表示を省略して壊れないように自分で気を遣ってくれる。しかも、警告にかかわらず表示したとして、編集ができなくなるくらい重たくなることはまれである。この点は本当に素直に感動した。VS Code は細かいところの作り込みがすごい。</p><p>思い返すと、VS Code の黎明期、同じく Electron を採用している Atom との比較をよく見かけた気がする。大規模ファイルの置換などでパフォーマンスを比較するような記事を見た記憶があるが、その記憶の中では、その時点でも圧倒的なパフォーマンス優位を誇っていた。このあたりも VS Code チームの最適化のたまものなんだろうな。例えば VS Code の最適化の一端を知りたい方は<a href=https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation>テキストバッファのリファクタリング</a>を読んでいただくのがおすすめ。</p><p>ちなみに当然、Neovimmer なので、巨大ファイルに対して一部機能を停止するような仕組みを init.lua に設定することはした。
すなわち BufReadPre で、ファイルのサイズが一定以上である場合、syntax off を始めとして重そうな機能を可能な限り無効化することで軽量に操作できるようにするというものである。
ただ、それによってどれくらいの無効化ができるのかは結局プラグイン次第である部分が多く、たとえば coc.nvim はバッファ単位で処理を無効化することはできなかったので、coc.nvim 全体を停止させていた。それでも助かることがあるので残してあるが、お世辞にも使い勝手が良いとは言えない機能である。</p><h2 id=結び>結び</h2><p>6500 行を超える設定を書いてきた Neovimmer として、Neovim の自由度と柔軟性は今でも魅力的だと感じている。しかし、開発環境に求めるものが「すべてのニーズを一つで満たせる家」であるならば、現時点では VS Code がその理想に最も近いと認めざるを得ない。</p><p>ただ、いずれにしても私の精神的な出身地が (Neo)vim であることは変わりないし、VS Code に移行してからも設定する営みはやめるつもりはない。別に既存の枠組みの中で小さく生きようと考えているわけではないのだ。</p><p>VS Code では、早速 Waltz というモーダル編集用の拡張機能を新たに作っている。この記事を含め日常利用しているが、かなり良い感じに使えている。
というか、本来はこの記事でその拡張機能の宣伝 (?) をするつもりだった。が、思ったよりも話が長くなってしまったので、回を改めることにした。</p><p>理想の開発環境は時代とともに変わる。これだけ言葉を並べておきながら、明日にはまた Neovim に戻っている可能性だってなくはない。</p></div></article></main><footer class=site-footer><div class=footer-content><p>&copy; 2025 statiolake &dash; All rights reserved.</p><div class=social-links><a href=https://x.com/statiolake target=_blank rel="noopener noreferrer" aria-label=Twitter><i class="fa-brands fa-x-twitter"></i>
</a><a href=https://github.com/statiolake target=_blank rel="noopener noreferrer" aria-label=GitHub><i class="fa-brands fa-github"></i></a></div></div></footer></body></html>